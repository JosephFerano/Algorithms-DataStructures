#+TITLE: Notes & Exercises: Grokking Algorithms
#+AUTHOR: Joseph Ferano

* Random

** Recursive sum

*** OCaml
#+begin_src ocaml
let rec sum_rec = function
  | [] -> 0
  | n::ns -> n + sum_rec ns;;

sum_rec [2;3;4;2;1];;
#+end_src

#+RESULTS:
: 12

#+begin_src ocaml
let sum_rec_tail list =
  let rec f acc = function
  | [] -> 0
  | n::ns -> sum_rec (acc + n) ns
  in f 0 list;;

sum_rec [2;3;4;2;1];;
#+end_src

#+RESULTS:
: 12

*** Python

#+begin_src python :results output
def sum_rec(arr):
    if not arr:
        return 0
    else:
        return arr[0] + sum_rec(arr[1:])

print(sum_rec([1,2,3]))
#+end_src

#+RESULTS:
: 6

** Quicksort

*** Python
#+begin_src python
import random

def quicksort(arr):
    if len(arr) < 2:
        return arr
    elif len(arr) == 2:
        if arr[0] > arr[1]:
            temp = arr[1]
            arr[1] = arr[0]
            arr[0] = temp
        return arr
    else:
        # Pick a random pivot
        index = random.randrange(0, len(arr))
        pivot = arr.pop(index)
        left = [x for x in arr if x <= pivot]
        right = [x for x in arr if x > pivot]
        return quicksort(left) + [pivot] + quicksort(right)
#+end_src

